---
marp: true
title: 'Elixir 遇见 Rust'
paginate: false
_paginate: false
theme: uncover
---

<!-- backgroundColor: #F7F8F8 -->

![bg](assets/tubi.png)
![](#fff)

##
##
##
##
##
##
##
##

### Elixir 遇见 Rust

---


![bg left](assets/about.jpg)

## 关于我

- 女儿奴
- elixir, rust, flutter 爱好者
- 懒散的码字农：
  - [《途客圈创业记》](https://book.douban.com/subject/26739566/)
  - 公众号：程序人生/天叔奇谈
  - 知乎：[迷思](https://zhuanlan.zhihu.com/prattle)
- 不成功的 up 主
  - [喜欢历史的程序君](https://space.bilibili.com/39222989)
- 马拉松入门选手
  - 最好成绩：4h32m (2019 portland)

---

## Elixir 的美妙之处

- 隔离（isolation）
- 容错和自我恢复（fault tolerant & self-healing）
- 安全并发（fearless concurrency）
- 语言表达力强（expressiveness）

---

## Elixir 的不足

- 性能（performance）
- 生态（ecosystem）
- 底层开发（low-level support）

---

## 如何解决？

- ports (mix, inet_drv)
- _NIFs_ (jiffy)
- 用其他语言撰写服务（如 gRPC）

---
<!-- _backgroundColor: #ffffed -->
## NIF 例子

```elixir
defmodule Jaxon.Parsers.NifParser do
  @moduledoc false
  @on_load :load_nifs
  @behaviour Jaxon.Parser

  def load_nifs do
    nif_filename =
      :jaxon
      |> Application.app_dir("priv/decoder")
      |> to_charlist

    :erlang.load_nif(nif_filename, [:start_object, :end_object, :start_array, :end_array, :comma,
      :colon, :string, :decimal, :integer, :boolean, nil, true, false, :error, :yield, :ok, :incomplete, :end
    ])
  end

  @spec parse_nif(String.t()) ::
          [Jaxon.Event.t()] | {:yield, [Jaxon.Event.t()], String.t()} | no_return()
  defp parse_nif(_) do
    :erlang.nif_error("Jaxon.Parsers.NifParser.parse_nif/1: NIF not compiled")
  end
```

代码来源：[nif_parser](https://github.com/boudra/jaxon/blob/master/lib/jaxon/parsers/nif_parser.ex) | [decoder_nif.c](https://github.com/boudra/jaxon/blob/master/c_src/decoder_nif.c)


---

## NIFs：优势和不足

- 优势：
  - 功能已经在别处实现，比如 C/C++/rust
  - 运行速度最快
  - （相对）容易撰写和维护
  - 和 VM 运行在同一个进程空间，没有上下文切换开销
- 不足：
  - 现有的 C/C++ 解决方案不够安全（可以 crash VM 或者导致内存泄漏）

---

## Rust

- 执行效率媲美 C/C++
- 内存安全和并发安全
- 零成本抽象
- 语言表达力很强
- 强大的让人爱不释手的类型系统

---

### Rustler：为 elixir/rust 建起一座桥

- 安全：你撰写的 safe rust 不会 crash VM
- 互操作：数据在两种语言之间可以很方便地传递
  - Rust struct <-> elixir term
- 高效：数据可以按引用传递；当不再引用时自动销毁

---

<!-- _backgroundColor: #222831 -->
<!-- _color: #fff -->

## 如何使用 rustler？

以 markdown -> html compiler 为例

---

## mix.exs
<!-- _backgroundColor: #ffffed -->

```elixir
def project do
[
    ...
    compilers: [:rustler] ++ Mix.compilers,
    rustler_crates: [rmark: [
        path: "native/rmark",
        mode: rustc_mode(Mix.env)
    ]],
    ...
    defp rustc_mode(:prod), do: :release
    defp rustc_mode(_), do: :debug
]

defp deps do
[
    ...
    {:rustler, "~> 0.21.0"},
    ...
]
```
---

## 创建 rust 项目
<!-- _backgroundColor: #ffffed -->

```bash
➜ mix rustler.new
This is the name of the Elixir module the NIF module will be registered to.
Module name > Rmark
This is the name used for the generated Rust crate. The default is most likely fine.
Library name (rmark) >
* creating native/rmark/.cargo/config
* creating native/rmark/README.md
* creating native/rmark/Cargo.toml
* creating native/rmark/src/lib.rs
Ready to go! See /Users/tchen/projects/mycode/elixir/elixir-meet-rust/rmark/native/rmark/README.md for further instructions.

```

---
<!-- _backgroundColor: #ffffed -->

## lib/lib.ex

```elixir
defmodule Rmark do
  @moduledoc """
  Documentation for `Rmark`.
  """

  # NOTE: @on_load is automatically generated by this `use`
  use Rustler, otp_app: :rmark, crate: :rmark

  def to_html(_md), do: :erlang.nif_error(:nif_not_loaded)
end
```

---
<!-- _backgroundColor: #ffffed -->

## native/cargo.toml

```toml
[dependencies]
...
rustler = "0.21.0"
...
```

---
<!-- _backgroundColor: #ffffed -->

## native/src/lib.rs

```rust
use rustler::{Encoder, Env, Error, Term};
use comrak::{markdown_to_html, ComrakOptions};

mod atoms {
    rustler::rustler_atoms! {
        atom ok;
        //atom error;
        //atom __true__ = "true";
        //atom __false__ = "false";
    }
}

rustler::rustler_export_nifs! {
    "Elixir.Rmark", [
        ("to_html", 1, to_html)
    ],
    None
}

fn to_html<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {
    let md: String = args[0].decode()?;
    Ok((atoms::ok(), markdown_to_html(&md, &ComrakOptions::default())).encode(env))
}
```

---

## 有什么问题？

---

![bg right contain](assets/erlang_scheduler.png)

#### 输入如果非常大，会阻塞 scheduler

- erlang 内部调度模型：cooperative multitasking，2000 reds/round
- NIF 应该避免过度占用 scheduler

---

## 解决方案

- 对输入数据进行切片
- ~~在 NIF 中允许被调度~~（rustler 尚无完整支持）
- 使用 rust thread（异步处理）
- Dirty Scheduler（> OTP 20，无痛方案）

---
<!-- _backgroundColor: #ffffed -->

## Rust thread

```rust
fn to_html_spawn<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {
    let md: String = args[0].decode()?;
    use rustler::thread;
    thread::spawn::<thread::ThreadSpawner, _>(env, move |env| {
        (
            atoms::ok(),
            markdown_to_html(&md, &ComrakOptions::default()),
        )
            .encode(env)
    });
    Ok(atoms::ok().encode(env))
}
```

```elixir
def to_html2(md) do
  :ok = to_html_spawn(md)

  receive do
    {:ok, result} -> {:ok, result}
    {:error, error} -> {:error, error}
  after
    5000 ->
      {:error, :timeout}
  end
end
```

---
<!-- _backgroundColor: #ffffed -->
## Dirty Scheduler

```rust
use rustler::schedule::SchedulerFlags::DirtyCpu;

rustler::rustler_export_nifs! {
    "Elixir.Rmark",
    [
        ("to_html", 1, to_html),
        ("to_html_spawn", 1, to_html_spawn),
        ("to_html_dirty", 1, to_html, DirtyCpu),
    ],
    None
}
```

---

<!-- _backgroundColor: #ffffed -->

## Benchmark

```bash
➜ mix run benchmark/markdown.exs
Compiling NIF crate :rmark (native/rmark)...
    Finished dev [unoptimized + debuginfo] target(s) in 2.05s
Operating System: macOS
CPU Information: Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz
Number of Available Cores: 16
Available memory: 64 GB
Elixir 1.10.2
Erlang 22.3.2

...

Name                  ips        average  deviation         median         99th %
rmark              173.29        5.77 ms     ±6.42%        5.63 ms        7.59 ms
rmark_spawn        169.61        5.90 ms     ±7.71%        5.72 ms        8.16 ms
rmark_dirty        168.86        5.92 ms     ±8.82%        5.68 ms        7.57 ms
earmark             78.80       12.69 ms     ±8.57%       12.55 ms       16.10 ms

Comparison:
rmark              173.29
rmark_spawn        169.61 - 1.02x slower +0.125 ms
rmark_dirty        168.86 - 1.03x slower +0.151 ms
earmark             78.80 - 2.20x slower +6.92 ms
```

---

## 看上去不怎么样嘛？我辛辛苦苦写 rust，就快了一倍？？？

---
<!-- _backgroundColor: #ffffed -->
## Benchmark with prod

```bash
➜ mix run benchmark/markdown.exs
Compiling NIF crate :rmark (native/rmark)...
    Finished release [optimized] target(s) in 0.03s
Operating System: macOS
CPU Information: Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz
Number of Available Cores: 16
Available memory: 64 GB
Elixir 1.10.2
Erlang 22.3.2

...

Name                  ips        average  deviation         median         99th %
rmark              2.39 K      419.01 μs    ±11.72%         407 μs      662.14 μs
rmark_dirty        2.10 K      476.58 μs    ±13.78%         464 μs         787 μs
rmark_spawn        1.95 K      514.06 μs    ±14.77%         496 μs      883.74 μs
earmark          0.0806 K    12408.99 μs     ±7.81%       12262 μs    15110.40 μs

Comparison:
rmark              2.39 K
rmark_dirty        2.10 K - 1.14x slower +57.57 μs
rmark_spawn        1.95 K - 1.23x slower +95.05 μs
earmark          0.0806 K - 29.61x slower +11989.98 μs
```

---

## 我们没有讲什么？

- ResourceObject

---

<!-- _backgroundColor: #222831 -->
<!-- _color: #fff -->

## Live coding

让 elixir 支持 [Roaring Bitmap](https://github.com/Nemo157/roaring-rs)

---

## 谢谢！
